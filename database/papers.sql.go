// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: papers.sql

package database

import (
	"context"
)

const addPaper = `-- name: AddPaper :one
INSERT INTO papers (name, cost_per_square_inch, finish) VALUES (?1, ?2, ?3) RETURNING id, name, cost_per_square_inch, finish
`

type AddPaperParams struct {
	Name              string  `json:"name"`
	CostPerSquareInch float64 `json:"costPerSquareInch"`
	Finish            string  `json:"finish"`
}

func (q *Queries) AddPaper(ctx context.Context, arg AddPaperParams) (Paper, error) {
	row := q.queryRow(ctx, q.addPaperStmt, addPaper, arg.Name, arg.CostPerSquareInch, arg.Finish)
	var i Paper
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CostPerSquareInch,
		&i.Finish,
	)
	return i, err
}

const deletePaper = `-- name: DeletePaper :exec
DELETE FROM papers WHERE id = ?1
`

func (q *Queries) DeletePaper(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deletePaperStmt, deletePaper, id)
	return err
}

const getPapers = `-- name: GetPapers :many
SELECT id, name, cost_per_square_inch, finish FROM papers
`

func (q *Queries) GetPapers(ctx context.Context) ([]Paper, error) {
	rows, err := q.query(ctx, q.getPapersStmt, getPapers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Paper
	for rows.Next() {
		var i Paper
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CostPerSquareInch,
			&i.Finish,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePaper = `-- name: UpdatePaper :exec
UPDATE papers SET name = ?1, cost_per_square_inch = ?2, finish = ?3 WHERE id = ?4
`

type UpdatePaperParams struct {
	Name              string  `json:"name"`
	CostPerSquareInch float64 `json:"costPerSquareInch"`
	Finish            string  `json:"finish"`
	ID                int64   `json:"id"`
}

func (q *Queries) UpdatePaper(ctx context.Context, arg UpdatePaperParams) error {
	_, err := q.exec(ctx, q.updatePaperStmt, updatePaper,
		arg.Name,
		arg.CostPerSquareInch,
		arg.Finish,
		arg.ID,
	)
	return err
}
